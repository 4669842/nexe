{"name":"nexe","tagline":"Create a single executable out of your node.js app","body":"## Installation\r\n\r\n```bash\r\nnpm install nexe [-g]\r\n```\r\n\r\n### Motivation\r\n\r\n- Ability to run multiple applications with *different* node.js runtimes.\r\n- Distributable binaries without needing node / npm.\r\n- Starts faster.\r\n- Lockdown specific application versions, and easily rollback.\r\n- Faster deployments.\r\n\r\n## Building Requirements\r\n\r\n- Linux / Mac / BSD / Windows\r\n- Python 2.6 or 2.7 (use --python if not in PATH)\r\n- Windows: Visual Studio 2010+\r\n\r\n## Caveats\r\n\r\n### Doesn't support native modules\r\n\r\n- Use the techniques below for working around dynamic require statements to exclude the module from the bundling, and deploy along side the executable in a node_module folder so your app can find it. Note: On windows you may need to have your app be named node.exe if .node file depends on node.\r\n\r\n### Doesn't support dynamic require statements\r\n\r\nSuch As:\r\n\r\n```javascript\r\nvar x = require(someVar);\r\n```\r\n\r\nIn this case nexe won't bundle the file\r\n\r\n```javascript\r\n\tvar x;\r\n\tif (someCheck) {\r\n\t\tx = require(\"./ver1.js\");\r\n\t} else {\r\n\t\tx = require(\"./var2.js\");\r\n\t}\r\n```\r\n\r\nIn this case nexe will bundle both files.\r\n\r\nWorkarounds:\r\n1) for dynamic requires that you want bundled add the following into your project\r\n\r\n```javascript\r\n\tvar dummyToForceIncludeForBundle = false;\r\n\tif (dummyToForceIncludeForBundle) {\r\n\t\trequire(\"./loadedDynamicallyLater.js\");\r\n\t\t// ...\r\n\t}\r\n```\r\nthis will trick the bundler into including them.\r\n\r\n2) for dynamic files getting included that you don't want to be\r\n\r\n```javascript\r\n\tvar moduleName = \"./ver2.js\";\r\n\tif (someCheck) {\r\n\t\tmoduleName = \"./ver1.js\";\r\n\t}\r\n\tvar x = require(moduleName);\r\n```\r\nNote: neither file will be bundled.\r\n\r\nUsing these two techniques you can change your application code so modules are not bundles, and generate a includes.js file as part of your build process so that the right files get bundled for your build configuration.\r\n\r\n### &#95;&#95;dirname\r\n\r\nOnce the module is bundled it is part of the executable. &#95;&#95;dirname is therefore the executable dir (process.execPath). Thus if you put resources on a relative path from the the executable your app will be able to access them.\r\n\r\nIf you had a data file at `/dev/myNodeApp/stateManager/handler/data/some.csv`\r\nand a file at `/dev/myNodeApp/stateManager/handler/loader.js`\r\n\r\n```javascript\r\n\tmodule.exports = fw.readFileSync(path.join(__dirname, \"./data/some.csv\"));\r\n```\r\nYou would need to deploy some.csv in a sub dir `data/` along side your executable\r\n\r\nThere are potential use cases for &#95;&#95;dirname where the executable path is not the correct substitution, and could result in a silent error (possibly even in a dependency that you are unaware of).\r\n\r\nNote: &#95;&#95;filename will be 'undefined'\r\n\r\n### child_process.fork\r\n\r\nchild_process.spawn works is unmodified, but child_process.fork will make an attempt to launch a new instance of your executable and run the bundled module.\r\n\r\n### CLI Usage\r\n\r\n```text\r\n\r\nUsage: nexe -i [sources] -o [binary] [options]\r\n\r\nOptions:\r\n\t-i, --input    The entry javascript files         [default: cwd]\r\n\t-o, --output   The output binary                  [default: out.nex]\r\n\t-r, --runtime  The node.js runtime to use         [default: \"latest\"]\r\n\t-t, --temp     The path to store node.js sources  [default: ./tmp/nexe]\r\n\t-f, --flags    Don't parse node and v8 flags, pass through app flags  [default: false]\r\n\t-v, --version  Display version number\r\n\t-p, --python   Set path of python to use.         [default: \"python\"]\r\n\t-F, --framework Set the framework to use.          [default: \"nodejs\"]\r\n\r\n```\r\n\r\n\r\n### Code Usage\r\n\r\n```javascript\r\n\r\nvar nexe = require('nexe');\r\n\r\nnexe.compile({\r\n\tinput: 'input.js',\r\n\toutput: 'path/to/bin',\r\n\tnodeVersion: '0.12.5',\r\n\tnodeTempDir: 'src',\r\n\tpython: 'path/to/python',\r\n\tresourceFiles: [ 'path/to/a/file' ],\r\n\tflags: true,\r\n\tframework: \"nodejs\"\r\n}, function(err) {\r\n\tconsole.log(err);\r\n});\r\n\r\n```\r\n\r\n### package.json inclusion\r\n\r\nAs of 0.4.0 you can now embed nexe options into package.json. Note that this Format\r\nis still in works, so it is likely to change.\r\n\r\n```\r\n\"nexe\": {\r\n\t\"input\": \"./bin/nexe\",\r\n\t\"output\": \"nexe^$\",\r\n\t\"temp\": \"src\",\r\n\t\"runtime\": {\r\n\t\t\"framework\": \"iojs\",\r\n\t\t\"version\": \"2.3.1\",\r\n\t\t\"ignoreFlags\": true\r\n\t}\r\n}\r\n```\r\n\r\nNotes:\r\n\r\n* output: can use ^$ for platform specific file extension\r\n\r\n## Maintainers\r\n\r\n* __Jared Allard__ ([@jaredallard](https://github.com/jaredallard)) &lt;[jaredallard@outlook.com](mailto:jaredallard@outlook.com)&gt; (Active)\r\n* __Christopher Karper__ ([@ckarper](https://github.com/CKarper)) &lt;[Christopher.Karper@gmail.com](mailto:Christopher.Karper@gmail.com)&gt; (Active)\r\n* __Craig Jefferds__ ([@crcn](https://github.com/crcn)) &lt;[craig.j.condon@gmail.com](mailto:craig.j.condon@gmail.com)&gt; (Not Active)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}